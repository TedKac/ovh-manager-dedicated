//
// randexp v0.3.3
// Create random strings that match a given regular expression.
//
// Copyright (C) 2013 by Roly Fentanes (https://github.com/fent)
// MIT License
// http://github.com/fent/randexp.js/raw/master/LICENSE
//
!(function () {
  var a = function (b, c) { const d = a.resolve(b, c || '/'); const e = a.modules[d]; if (!e) throw new Error(`Failed to resolve module ${b}, tried ${d}`); const f = e._cached ? e._cached : e(); return f; }; a.paths = [], a.modules = {}, a.extensions = ['.js', '.coffee'], a._core = {
    assert: !0, events: !0, fs: !0, path: !0, vm: !0,
  }, a.resolve = (function () { return function (b, c) { function h(b) { if (a.modules[b]) return b; for (let c = 0; c < a.extensions.length; c++) { const d = a.extensions[c]; if (a.modules[b + d]) return b + d; } } function i(b) { b = b.replace(/\/+$/, ''); const c = `${b}/package.json`; if (a.modules[c]) { const e = a.modules[c](); const f = e.browserify; if (typeof f === 'object' && f.main) { var g = h(d.resolve(b, f.main)); if (g) return g; } else if (typeof f === 'string') { var g = h(d.resolve(b, f)); if (g) return g; } else if (e.main) { var g = h(d.resolve(b, e.main)); if (g) return g; } } return h(`${b}/index`); } function j(a, b) { const c = k(b); for (let d = 0; d < c.length; d++) { const e = c[d]; var f = h(`${e}/${a}`); if (f) return f; const g = i(`${e}/${a}`); if (g) return g; } var f = h(a); if (f) return f; } function k(a) { let b; a === '/' ? b = [''] : b = d.normalize(a).split('/'); const c = []; for (let e = b.length - 1; e >= 0; e--) { if (b[e] === 'node_modules') continue; const f = `${b.slice(0, e + 1).join('/')}/node_modules`; c.push(f); } return c; }c || (c = '/'); if (a._core[b]) return b; var d = a.modules.path(); const e = c || '.'; if (b.match(/^(?:\.\.?\/|\/)/)) { const f = h(d.resolve(e, b)) || i(d.resolve(e, b)); if (f) return f; } const g = j(b, e); if (g) return g; throw new Error(`Cannot find module '${b}'`); }; }()), a.alias = function (b, c) { const d = a.modules.path(); let e = null; try { e = a.resolve(`${b}/package.json`, '/'); } catch (f) { e = a.resolve(b, '/'); } const g = d.dirname(e); const h = (Object.keys || function (a) { const b = []; for (const c in a)b.push(c); return b; })(a.modules); for (let i = 0; i < h.length; i++) { const j = h[i]; if (j.slice(0, g.length + 1) === `${g}/`) { const k = j.slice(g.length); a.modules[c + k] = a.modules[g + k]; } else j === g && (a.modules[c] = a.modules[g]); } }, a.define = function (b, c) { const d = a._core[b] ? '' : a.modules.path().dirname(b); const e = function (b) { return a(b, d); }; e.resolve = function (b) { return a.resolve(b, d); }, e.modules = a.modules, e.define = a.define; const f = { exports: {} }; a.modules[b] = function () { return a.modules[b]._cached = f.exports, c.call(f.exports, e, f, f.exports, d, b), a.modules[b]._cached = f.exports, f.exports; }; }, typeof process === 'undefined' && (process = {}), process.nextTick || (process.nextTick = (function () { const a = []; const b = typeof window !== 'undefined' && window.postMessage && window.addEventListener; return b && window.addEventListener('message', (b) => { if (b.source === window && b.data === 'browserify-tick') { b.stopPropagation(); if (a.length > 0) { const c = a.shift(); c(); } } }, !0), function (c) { b ? (a.push(c), window.postMessage('browserify-tick', '*')) : setTimeout(c, 0); }; }())), process.title || (process.title = 'browser'), process.binding || (process.binding = function (b) { if (b === 'evals') return a('vm'); throw new Error('No such module'); }), process.cwd || (process.cwd = function () { return '.'; }), a.define('path', (a, b, c, d, e) => { function f(a, b) { const c = []; for (let d = 0; d < a.length; d++)b(a[d], d, a) && c.push(a[d]); return c; } function g(a, b) { let c = 0; for (let d = a.length; d >= 0; d--) { const e = a[d]; e == '.' ? a.splice(d, 1) : e === '..' ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--); } if (b) for (;c--; c)a.unshift('..'); return a; } const h = /^(.+\/(?!$)|\/)?((?:.+?)?(\.[^.]*)?)$/; c.resolve = function () { let a = ''; let b = !1; for (let c = arguments.length; c >= -1 && !b; c--) { const d = c >= 0 ? arguments[c] : process.cwd(); if (typeof d !== 'string' || !d) continue; a = `${d}/${a}`, b = d.charAt(0) === '/'; } return a = g(f(a.split('/'), a => !!a), !b).join('/'), (b ? '/' : '') + a || '.'; }, c.normalize = function (a) { const b = a.charAt(0) === '/'; const c = a.slice(-1) === '/'; return a = g(f(a.split('/'), a => !!a), !b).join('/'), !a && !b && (a = '.'), a && c && (a += '/'), (b ? '/' : '') + a; }, c.join = function () { const a = Array.prototype.slice.call(arguments, 0); return c.normalize(f(a, (a, b) => a && typeof a === 'string').join('/')); }, c.dirname = function (a) { const b = h.exec(a)[1] || ''; const c = !1; return b ? b.length === 1 || c && b.length <= 3 && b.charAt(1) === ':' ? b : b.substring(0, b.length - 1) : '.'; }, c.basename = function (a, b) { let c = h.exec(a)[2] || ''; return b && c.substr(-1 * b.length) === b && (c = c.substr(0, c.length - b.length)), c; }, c.extname = function (a) { return h.exec(a)[3] || ''; }; }), a.define('/node_modules/ret/package.json', (a, b, c, d, e) => { b.exports = { main: './lib/index.js' }; }), a.define('/node_modules/ret/lib/index.js', (a, b, c, d, e) => {
    const f = a('./util'); const g = a('./types'); const h = a('./sets'); const i = a('./positions'); b.exports = function (a) {
      let b = 0; let c; let d; const e = { type: g.ROOT, stack: [] }; let j = e; let k = e.stack; const l = []; const m = function (b) { f.error(a, `Nothing to repeat at column ${b - 1}`); }; const n = f.strToChars(a); c = n.length; while (b < c) {
        d = n[b++]; switch (d) {
          case '\\': d = n[b++]; switch (d) { case 'b': k.push(i.wordBoundary()); break; case 'B': k.push(i.nonWordBoundary()); break; case 'w': k.push(h.words()); break; case 'W': k.push(h.notWords()); break; case 'd': k.push(h.ints()); break; case 'D': k.push(h.notInts()); break; case 's': k.push(h.whitespace()); break; case 'S': k.push(h.notWhitespace()); break; default: /\d/.test(d) ? k.push({ type: g.REFERENCE, value: parseInt(d, 10) }) : k.push({ type: g.CHAR, value: d.charCodeAt(0) }); } break; case '^': k.push(i.begin()); break; case '$': k.push(i.end()); break; case '[': var o; n[b] === '^' ? (o = !0, b++) : o = !1; var p = f.tokenizeClass(n.slice(b), a); b += p[1], k.push({ type: g.SET, set: p[0], not: o }); break; case '.': k.push(h.anyChar()); break; case '(': var q = { type: g.GROUP, stack: [], remember: !0 }; d = n[b], d === '?' && (d = n[b + 1], b += 2, d === '=' ? q.followedBy = !0 : d === '!' ? q.notFollowedBy = !0 : d !== ':' && f.error(a, `Invalid group, character '${d}' after '?' at column ${b - 1}`), q.remember = !1), k.push(q), l.push(j), j = q, k = q.stack; break; case ')': l.length === 0 && f.error(a, `Unmatched ) at column ${b - 1}`), j = l.pop(), k = j.options ? j.options[j.options.length - 1] : j.stack; break; case '|': j.options || (j.options = [j.stack], delete j.stack); var r = []; j.options.push(r), k = r; break; case '{': var s = /^(\d+)(,(\d+)?)?\}/.exec(n.slice(b)); var t; var u; s !== null ? (t = parseInt(s[1], 10), u = s[2] ? s[3] ? parseInt(s[3], 10) : Infinity : t, b += s[0].length, k.push({
            type: g.REPETITION, min: t, max: u, value: k.pop(),
          })) : k.push({ type: g.CHAR, value: 123 }); break; case '?': k.length === 0 && m(b), k.push({
            type: g.REPETITION, min: 0, max: 1, value: k.pop(),
          }); break; case '+': k.length === 0 && m(b), k.push({
            type: g.REPETITION, min: 1, max: Infinity, value: k.pop(),
          }); break; case '*': k.length === 0 && m(b), k.push({
            type: g.REPETITION, min: 0, max: Infinity, value: k.pop(),
          }); break; default: k.push({ type: g.CHAR, value: d.charCodeAt(0) });
        }
      } return l.length !== 0 && f.error(a, 'Unterminated group'), e;
    }, b.exports.types = g;
  }), a.define('/node_modules/ret/lib/util.js', (a, b, c, d, e) => {
    const f = a('./types'); const g = a('./sets'); const h = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?'; const i = {
      0: 0, t: 9, n: 10, v: 11, f: 12, r: 13,
    }; c.strToChars = function (a) { const b = /(\[\\b\])|\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z\[\\\]\^?])|([0tnvfr]))/g; return a = a.replace(b, (a, b, c, d, e, f, g) => { const j = b ? 8 : c ? parseInt(c, 16) : d ? parseInt(d, 16) : e ? parseInt(e, 8) : f ? h.indexOf(f) : g ? i[g] : undefined; let k = String.fromCharCode(j); return /[\[\]{}\^$.|?*+()]/.test(k) && (k = `\\${k}`), k; }), a; }, c.tokenizeClass = function (a, b) { const d = []; const e = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\\]))-(?:\\)?([^\]]))|(\])|(?:\\)?(.)/g; let h; let i; while ((h = e.exec(a)) != null) if (h[1])d.push(g.words()); else if (h[2])d.push(g.ints()); else if (h[3])d.push(g.whitespace()); else if (h[4])d.push(g.notWords()); else if (h[5])d.push(g.notInts()); else if (h[6])d.push(g.notWhitespace()); else if (h[7])d.push({ type: f.RANGE, from: (h[8] || h[9]).charCodeAt(0), to: h[10].charCodeAt(0) }); else { if (!(i = h[12])) return [d, e.lastIndex]; d.push({ type: f.CHAR, value: i.charCodeAt(0) }); }c.error(b, 'Unterminated character class'); }, c.error = function (a, b) { throw new SyntaxError(`Invalid regular expression: /${a}/: ${b}`); };
  }), a.define('/node_modules/ret/lib/types.js', (a, b, c, d, e) => {
    b.exports = {
      ROOT: 0, GROUP: 1, POSITION: 2, SET: 3, RANGE: 4, REPETITION: 5, REFERENCE: 6, CHAR: 7,
    };
  }), a.define('/node_modules/ret/lib/sets.js', (a, b, c, d, e) => { const f = a('./types'); const g = function () { return [{ type: f.RANGE, from: 48, to: 57 }]; }; const h = function () { return [{ type: f.RANGE, from: 97, to: 122 }, { type: f.RANGE, from: 65, to: 90 }].concat(g()); }; const i = function () { return [{ type: f.CHAR, value: 12 }, { type: f.CHAR, value: 10 }, { type: f.CHAR, value: 13 }, { type: f.CHAR, value: 9 }, { type: f.CHAR, value: 11 }, { type: f.CHAR, value: 160 }, { type: f.CHAR, value: 5760 }, { type: f.CHAR, value: 6158 }, { type: f.CHAR, value: 8192 }, { type: f.CHAR, value: 8193 }, { type: f.CHAR, value: 8194 }, { type: f.CHAR, value: 8195 }, { type: f.CHAR, value: 8196 }, { type: f.CHAR, value: 8197 }, { type: f.CHAR, value: 8198 }, { type: f.CHAR, value: 8199 }, { type: f.CHAR, value: 8200 }, { type: f.CHAR, value: 8201 }, { type: f.CHAR, value: 8202 }, { type: f.CHAR, value: 8232 }, { type: f.CHAR, value: 8233 }, { type: f.CHAR, value: 8239 }, { type: f.CHAR, value: 8287 }, { type: f.CHAR, value: 12288 }]; }; c.words = function () { return { type: f.SET, set: h(), not: !1 }; }, c.notWords = function () { return { type: f.SET, set: h(), not: !0 }; }, c.ints = function () { return { type: f.SET, set: g(), not: !1 }; }, c.notInts = function () { return { type: f.SET, set: g(), not: !0 }; }, c.whitespace = function () { return { type: f.SET, set: i(), not: !1 }; }, c.notWhitespace = function () { return { type: f.SET, set: i(), not: !0 }; }, c.anyChar = function () { return { type: f.SET, set: [{ type: f.CHAR, value: 10 }], not: !0 }; }; }), a.define('/node_modules/ret/lib/positions.js', (a, b, c, d, e) => { const f = a('./types'); c.wordBoundary = function () { return { type: f.POSITION, value: 'b' }; }, c.nonWordBoundary = function () { return { type: f.POSITION, value: 'B' }; }, c.begin = function () { return { type: f.POSITION, value: '^' }; }, c.end = function () { return { type: f.POSITION, value: '$' }; }; }), a.define('/randexp.js', (a, b, c, d, e) => { function h(a, b) { return a + Math.floor(Math.random() * (1 + b - a)); } function i(a) { return a + (a >= 97 && a <= 122 ? -32 : a >= 65 && a <= 90 ? 32 : 0); } function j(a, b, c, d) { return a <= c && c <= b ? { from: c, to: Math.min(b, d) } : a <= d && d <= b ? { from: Math.max(a, c), to: d } : !1; } function k(a, b) { let c; let d; let e; let f; if ((d = a.length) !== b.length) return !1; for (c = 0; c < d; c++) { f = a[c]; for (e in f) if (f.hasOwnProperty(e) && f[e] !== b[c][e]) return !1; } return !0; } function l(a, b) { for (let c = 0, d = a.length; c < d; c++) { const e = a[c]; if (e.not !== b.not && k(e.set, b.set)) return !0; } return !1; } function m(a, b, c) { let d; let e; const f = []; let h = !1; for (let k = 0, n = a.length; k < n; k++) { d = a[k]; switch (d.type) { case g.CHAR: e = d.value; if (e === b || c && i(e) === b) return !0; break; case g.RANGE: if (d.from <= b && b <= d.to || c && ((e = j(97, 122, d.from, d.to)) !== !1 && e.from <= b && b <= e.to || (e = j(65, 90, d.from, d.to)) !== !1 && e.from <= b && b <= e.to)) return !0; break; case g.SET: f.length > 0 && l(f, d) ? h = !0 : f.push(d); if (!h && m(d.set, b, c) !== d.not) return !0; } } return !1; } function n(a, b) { return String.fromCharCode(b && Math.random() > 0.5 ? i(a) : a); } function o(a, b, c) { let d; let e; let f; let i; let j; let k; let l; switch (a.type) { case g.ROOT: case g.GROUP: if (a.notFollowedBy) return ''; a.remember && (d = b.push(!1) - 1), e = a.options ? a.options[Math.floor(Math.random() * a.options.length)] : a.stack, f = ''; for (j = 0, k = e.length; j < k; j++)f += o.call(this, e[j], b); return a.remember && (b[d] = f), f; case g.POSITION: return ''; case g.SET: c = !!c, l = c !== a.not; if (!l) return a.set.length ? o.call(this, a.set[Math.floor(Math.random() * a.set.length)], b, l) : ''; for (;;) { const p = this.anyRandChar(); const q = p.charCodeAt(0); if (m(a.set, q, this.ignoreCase)) continue; return p; } break; case g.RANGE: return n(h(a.from, a.to), this.ignoreCase); case g.REPETITION: i = h(a.min, a.max === Infinity ? a.min + this.max : a.max), f = ''; for (j = 0; j < i; j++)f += o.call(this, a.value, b); return f; case g.REFERENCE: return b[a.value - 1] || ''; case g.CHAR: return n(a.value, this.ignoreCase); } } const f = a('ret'); var g = f.types; const p = b.exports = function (a, b) { if (a instanceof RegExp) this.ignoreCase = a.ignoreCase, this.multiline = a.multiline, typeof a.max === 'number' && (this.max = a.max), typeof a.anyRandChar === 'function' && (this.anyRandChar = a.anyRandChar), a = a.source; else { if (typeof a !== 'string') throw new Error('Expected a regexp or string'); this.ignoreCase = b && b.indexOf('i') !== -1, this.multiline = b && b.indexOf('m') !== -1; } this.tokens = f(a); }; p.prototype.max = 100, p.prototype.anyRandChar = function () { return String.fromCharCode(h(0, 65535)); }, p.prototype.gen = function () { return o.call(this, this.tokens, []); }; const q = p.randexp = function (a, b) { let c; return a._randexp === undefined ? (c = new p(a, b), a._randexp = c) : (c = a._randexp, typeof a.max === 'number' && (c.max = a.max), typeof a.anyRandChar === 'function' && (c.anyRandChar = a.anyRandChar)), c.gen(); }; p.sugar = function () { RegExp.prototype.gen = function () { return q(this); }; }; }), !(function (a, b) { typeof define === 'function' && typeof define.amd === 'object' ? define(a, () => b) : typeof window !== 'undefined' && (window[a] = b); }('RandExp', a('/randexp.js')));
}());
